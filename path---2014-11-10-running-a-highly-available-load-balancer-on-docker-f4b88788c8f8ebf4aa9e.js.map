{"version":3,"sources":["webpack:///path---2014-11-10-running-a-highly-available-load-balancer-on-docker-f4b88788c8f8ebf4aa9e.js","webpack:///./.cache/json/2014-11-10-running-a-highly-available-load-balancer-on-docker.json"],"names":["webpackJsonp","497","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,mBAAAC,OAAA,2BAA8DC,gBAAmBC,GAAA,+HAAAC,KAAA,2jJAAysHC,aAAoiCL,MAAA,qDAAAM,KAAA,+BAAkGC,aAAgBC,KAAA,kEAAAC,UAAqFC,QAAUF,KAAA,aAAmBH,aAAgBL,MAAA,YAAmBW,MAASD,QAAUF,KAAA,wEAA8EH,aAAgBL,MAAA","file":"path---2014-11-10-running-a-highly-available-load-balancer-on-docker-f4b88788c8f8ebf4aa9e.js","sourcesContent":["webpackJsonp([228256526782408],{\n\n/***/ 497:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"5π - fish's blog\",\"author\":\"Johannes 'fish' Ziemke\"}},\"markdownRemark\":{\"id\":\"/usr/src/src/pages/2014/11/10/running-a-highly-available-load-balancer-on-docker/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>For quite some time I felt like I should do a blog - again. Instead of spending time writting rants on facebook or commenting other peoples posting, I should write some blog articles!\\nThing is, it’s not that easy. Where to start? What should I talk about? What are you interested in reading?</p>\\n<p>Instead of diving into abstract thoughts about the universe and human kind, I’ll just present you how to run a highly available load balancer on Docker!</p>\\n<h3>Components</h3>\\n<p>For the load balancing part I’ve choosen haproxy. Since 1.5 it supports SSL termination. Since SSL is expensive, compared to running haproxy without it, we enable multiprocess support by specifying nbproc. Each request now may be handled by a different process. This is a problem for the stats endpoint: Since this endpoint exposes internal state which can’t be shared across multiple processes, you only get stats for the process which handles the current request.\\nTo still get metrics for all processes, you need to create a listen endpoint for each process and pin it to that process like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>listen stats01 :8001\\n  stats uri /\\n  stats auth admin:foobar23\\n  bind-process 1\\n  stats enable\\n\\nlisten stats02 :8002\\n  stats uri /\\n  stats auth admin:foobar23\\n  bind-process 2\\n  stats enable\\n\\nlisten stats03 :8003\\n  stats uri /\\n  stats auth admin:foobar23\\n  bind-process 3\\n  stats enable\\n...</code></pre>\\n      </div>\\n<p>With all that in place we can terminate SSL and load balance across multiple hosts but we still need to make this highly available.\\nThere are several ways to do that. I really like ECMP routing but that requires access to the routing layer which I don’t have. Then there is IPVS which is a good fit if you need to scale to multiple load balancers but it’s also harder and more complex to setup in my opinion.\\nBecause of that, I decided for UCARP which is a implementation of the CARP protocol for linux. CARP is similar to VRRP but patent free and uses cryptography to make it resilient against attackes on the protocol.\\nWhen running, it makes sure that there is only one CARP master and executes hooks to add or remove IP adresses.</p>\\n<h3>Docker Image</h3>\\n<p>I wrapped that all up in a easy to use <a href=\\\"https://registry.hub.docker.com/u/fish/haproxy/\\\">Docker image</a>.\\nTo configure haproxy and nginx, you can bind-mount the config location like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ docker run \\\\\\n-v /path/to/haproxy.cfg:/haproxy/haproxy.cfg \\\\\\n-v /path/to/nginx.d:/haproxy/nginx.d/ \\\\\\n--net=host --privileged fish/haproxy  \\\\\\n10.0.1.201 foobar23 [...additional IPs]</code></pre>\\n      </div>\\n<p><em>—net=host is required to access the real hosts interfaces. Privileged is necessary to allow the container to bind IPs. Instead of privileged mode, you probably can use —cap-add=NET_ADMIN</em></p>\\n<p>This will run nginx+haproxy+ucarp and make it listen on 10.0.1.201. You can start the same on another host in the same network and ucarp will make sure only one listens on 10.0.1.201. If you kill the active container, the passive one will failover.</p>\\n<p>Since bind-mounting makes things host dependent, I prefer using the fish/haproxy image as a base image and add my deployment specific configuration in a separated Dockerfile like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>FROM fish/haproxy\\nADD  . /haproxy\\nRUN  haproxy -c -f /haproxy/haproxy.cfg</code></pre>\\n      </div>\\n<p><em>The last RUN serves as a cheap test; It will prevent the build from suceeding if the configs are malformed</em></p>\\n<p>This Dockerfile overwrites haproxy.cfg and nginx.d/ in the image by using the files in the local directory.\\nJust build it with:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ docker build -t my-lb .</code></pre>\\n      </div>\\n<p>And run it as above. This has the downside that you need to rebuild the image on configuration changes and recreate the container to deploy it.</p>\\n<h3>Service Discovery</h3>\\n<p>If you’re using some configuration management system, you can just render the config on the host and bind-mount it. Still better than running you CM inside a container.\\nA much better solution is to use some kind of service registry for discovery of your backends. I haven’t found time for that yet, but I would suggest looking into <a href=\\\"http://consul.io\\\">consul</a>, <a href=\\\"https://github.com/progrium/registrator\\\">registrator</a> and <a href=\\\"https://github.com/kelseyhightower/confd\\\">confd</a>.</p>\",\"frontmatter\":{\"title\":\"Running a highly available load balancer on Docker\",\"date\":\"2014-11-10 19:18:57 +0000\"}}},\"pathContext\":{\"slug\":\"/2014/11/10/running-a-highly-available-load-balancer-on-docker/\",\"previous\":{\"fields\":{\"slug\":\"/hire-me/\"},\"frontmatter\":{\"title\":\"Hire me\"}},\"next\":{\"fields\":{\"slug\":\"/2014/11/13/using-docker-run-netcontainerxx-to-debug-network-issues/\"},\"frontmatter\":{\"title\":\"Using docker run --net=container:XX ... to debug network issues\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2014-11-10-running-a-highly-available-load-balancer-on-docker-f4b88788c8f8ebf4aa9e.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"5π - fish's blog\",\"author\":\"Johannes 'fish' Ziemke\"}},\"markdownRemark\":{\"id\":\"/usr/src/src/pages/2014/11/10/running-a-highly-available-load-balancer-on-docker/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>For quite some time I felt like I should do a blog - again. Instead of spending time writting rants on facebook or commenting other peoples posting, I should write some blog articles!\\nThing is, it’s not that easy. Where to start? What should I talk about? What are you interested in reading?</p>\\n<p>Instead of diving into abstract thoughts about the universe and human kind, I’ll just present you how to run a highly available load balancer on Docker!</p>\\n<h3>Components</h3>\\n<p>For the load balancing part I’ve choosen haproxy. Since 1.5 it supports SSL termination. Since SSL is expensive, compared to running haproxy without it, we enable multiprocess support by specifying nbproc. Each request now may be handled by a different process. This is a problem for the stats endpoint: Since this endpoint exposes internal state which can’t be shared across multiple processes, you only get stats for the process which handles the current request.\\nTo still get metrics for all processes, you need to create a listen endpoint for each process and pin it to that process like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>listen stats01 :8001\\n  stats uri /\\n  stats auth admin:foobar23\\n  bind-process 1\\n  stats enable\\n\\nlisten stats02 :8002\\n  stats uri /\\n  stats auth admin:foobar23\\n  bind-process 2\\n  stats enable\\n\\nlisten stats03 :8003\\n  stats uri /\\n  stats auth admin:foobar23\\n  bind-process 3\\n  stats enable\\n...</code></pre>\\n      </div>\\n<p>With all that in place we can terminate SSL and load balance across multiple hosts but we still need to make this highly available.\\nThere are several ways to do that. I really like ECMP routing but that requires access to the routing layer which I don’t have. Then there is IPVS which is a good fit if you need to scale to multiple load balancers but it’s also harder and more complex to setup in my opinion.\\nBecause of that, I decided for UCARP which is a implementation of the CARP protocol for linux. CARP is similar to VRRP but patent free and uses cryptography to make it resilient against attackes on the protocol.\\nWhen running, it makes sure that there is only one CARP master and executes hooks to add or remove IP adresses.</p>\\n<h3>Docker Image</h3>\\n<p>I wrapped that all up in a easy to use <a href=\\\"https://registry.hub.docker.com/u/fish/haproxy/\\\">Docker image</a>.\\nTo configure haproxy and nginx, you can bind-mount the config location like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ docker run \\\\\\n-v /path/to/haproxy.cfg:/haproxy/haproxy.cfg \\\\\\n-v /path/to/nginx.d:/haproxy/nginx.d/ \\\\\\n--net=host --privileged fish/haproxy  \\\\\\n10.0.1.201 foobar23 [...additional IPs]</code></pre>\\n      </div>\\n<p><em>—net=host is required to access the real hosts interfaces. Privileged is necessary to allow the container to bind IPs. Instead of privileged mode, you probably can use —cap-add=NET_ADMIN</em></p>\\n<p>This will run nginx+haproxy+ucarp and make it listen on 10.0.1.201. You can start the same on another host in the same network and ucarp will make sure only one listens on 10.0.1.201. If you kill the active container, the passive one will failover.</p>\\n<p>Since bind-mounting makes things host dependent, I prefer using the fish/haproxy image as a base image and add my deployment specific configuration in a separated Dockerfile like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>FROM fish/haproxy\\nADD  . /haproxy\\nRUN  haproxy -c -f /haproxy/haproxy.cfg</code></pre>\\n      </div>\\n<p><em>The last RUN serves as a cheap test; It will prevent the build from suceeding if the configs are malformed</em></p>\\n<p>This Dockerfile overwrites haproxy.cfg and nginx.d/ in the image by using the files in the local directory.\\nJust build it with:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ docker build -t my-lb .</code></pre>\\n      </div>\\n<p>And run it as above. This has the downside that you need to rebuild the image on configuration changes and recreate the container to deploy it.</p>\\n<h3>Service Discovery</h3>\\n<p>If you’re using some configuration management system, you can just render the config on the host and bind-mount it. Still better than running you CM inside a container.\\nA much better solution is to use some kind of service registry for discovery of your backends. I haven’t found time for that yet, but I would suggest looking into <a href=\\\"http://consul.io\\\">consul</a>, <a href=\\\"https://github.com/progrium/registrator\\\">registrator</a> and <a href=\\\"https://github.com/kelseyhightower/confd\\\">confd</a>.</p>\",\"frontmatter\":{\"title\":\"Running a highly available load balancer on Docker\",\"date\":\"2014-11-10 19:18:57 +0000\"}}},\"pathContext\":{\"slug\":\"/2014/11/10/running-a-highly-available-load-balancer-on-docker/\",\"previous\":{\"fields\":{\"slug\":\"/hire-me/\"},\"frontmatter\":{\"title\":\"Hire me\"}},\"next\":{\"fields\":{\"slug\":\"/2014/11/13/using-docker-run-netcontainerxx-to-debug-network-issues/\"},\"frontmatter\":{\"title\":\"Using docker run --net=container:XX ... to debug network issues\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2014-11-10-running-a-highly-available-load-balancer-on-docker.json\n// module id = 497\n// module chunks = 228256526782408"],"sourceRoot":""}